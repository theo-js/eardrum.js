{"version":3,"file":"eardrum.js","mappings":"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","sources":["webpack://eardrum/webpack/universalModuleDefinition","webpack://eardrum/./src/core/Eardrum.ts","webpack://eardrum/./src/core/configure/index.ts","webpack://eardrum/./src/core/configure/listen.ts","webpack://eardrum/./src/core/configure/validateEardrumConfigureArgs.ts","webpack://eardrum/./src/core/reset/index.ts","webpack://eardrum/./src/core/utils.ts","webpack://eardrum/webpack/bootstrap","webpack://eardrum/./src/eardrum.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"eardrum\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"eardrum\"] = factory();\n\telse\n\t\troot[\"eardrum\"] = factory();\n})(this, function() {\nreturn ","import configure from './configure';\r\nimport reset from './reset';\r\n\r\nexport default class Eardrum {\r\n\tconstructor () {\r\n\t\tthis.configure = configure.bind(this);\r\n\t\tthis.reset = reset.bind(this);\r\n\t}\r\n\tpublic configure: (args: EardrumConfigureArgs) => void;\r\n\tpublic reset: () => void;\r\n\r\n\tpublic Eardrum = Eardrum;\r\n\r\n\t// Stored values\r\n\treadonly refs: EventHandlerReference[] = [];\r\n\treadonly lastConfiguredObject: { current: EardrumSupportedObject|null } = { current: null };\r\n};","import Eardrum from '../Eardrum';\r\nimport validateEardrumConfigureArgs from './validateEardrumConfigureArgs';\r\nimport { installListener, ejectListener } from './listen';\r\nimport { isFunction, createPrivatePropName } from '../utils';\r\n\r\n/**\r\n * Configure object property to automatically manage event listeners \r\n *\r\n * @param {object} eardrumConfigureArgs Options object\r\n */\r\nexport default function configure (this: Eardrum, eardrumConfigureArgs: EardrumConfigureArgs): void {\r\n  // Validation\r\n  const eardrumConfigureArgsValidated = validateEardrumConfigureArgs(eardrumConfigureArgs);\r\n  const {\r\n    object,\r\n    property,\r\n    value,\r\n    handler\r\n  } = eardrumConfigureArgsValidated;\r\n\r\n  // Bind context\r\n  const install = installListener.bind(this, eardrumConfigureArgsValidated);\r\n  const eject = ejectListener.bind(this, eardrumConfigureArgsValidated);\r\n  /*\r\n  const ejectLast = ejectListener.bind(this, {\r\n    ...eardrumConfigureArgsValidated,\r\n    object: lastConfiguredObject.current\r\n  });\r\n  */\r\n\r\n  // Create private property\r\n  const _property = createPrivatePropName(property);\r\n\r\n  // Clear previous event listener\r\n  /*if (this.lastConfiguredObject.current /* && this.lastConfiguredObject.current === object *//*) {\r\n    ejectLast();\r\n  }*/\r\n  this.lastConfiguredObject.current = object;\r\n\r\n  // Attach initial event listener\r\n  if (isFunction(handler)) {\r\n  \tinstall();\r\n  }\r\n\r\n  // Define setter/getter for defaultReject\r\n  Object.defineProperties(object, {\r\n  \t[_property]: {\r\n  \t\tvalue: typeof value === 'undefined' ? object[property] : value,\r\n  \t\twritable: true,\r\n      configurable: true,\r\n      enumerable: false\r\n  \t},\r\n  \t[property]: {\r\n\t  \tget: function (this: EardrumSupportedObject): unknown {\r\n\t  \t\treturn this[_property];\r\n\t  \t},\r\n\t    set: function (this: EardrumSupportedObject, newValue: unknown): void {\r\n\t\t    // Clear previous event listener\r\n\t\t    eject();\r\n\r\n\t\t    // Replace defaultReject\r\n\t\t    this[_property] = newValue;\r\n\r\n\t\t    // Attach new listener\r\n\t\t    if (isFunction(newValue)) {\r\n\t        install();\r\n\t\t    }\r\n\t    },\r\n      configurable: true,\r\n      enumerable: true\r\n\t  }\r\n  });\r\n};","import Eardrum from '../Eardrum';\r\nimport { isEardrumSupportedObject, isEventTargetOrEmitter, isNodeEnv } from '../utils';\r\n\r\ninterface ListenWithCleanupOptions extends EardrumConfigureArgs {\r\n  attachMethodName: string;\r\n  detachMethodName: string;\r\n  attach: boolean;\r\n  listener: {\r\n    type: string;\r\n    target: EardrumTarget; // defaults to global object\r\n    options?: EventListenerOptions;\r\n  };\r\n  additionalRefProps: { [index: PropertyKey]: any }\r\n}\r\n/**\r\n * Store references of added handlers in an Array and remove from that\r\n *\r\n * @param {object} options EardrumConfigureArgs with additional parameters\r\n */\r\nfunction listenWithCleanup(this: Eardrum, {\r\n  attach,\r\n  attachMethodName, detachMethodName,\r\n  object,\r\n  listener,\r\n  handler,\r\n  listenerRemovalCondition,\r\n  additionalRefProps\r\n}: ListenWithCleanupOptions): void {\r\n  var { target, options } = listener;\r\n  var eventTarget = target as any; // allow indexation by string\r\n  var eventType =  listener.type;\r\n\r\n  if (!eventTarget[attachMethodName] || !eventTarget[detachMethodName]) {\r\n    throw new Error('Event target is invalid');\r\n  }\r\n\r\n  if (attach) {\r\n    // Add listener\r\n    eventTarget[attachMethodName](eventType, handler, options);\r\n\r\n    // Store reference to handler\r\n    var refToStore = { handler, eventType, options, object, target: eventTarget } as EventHandlerReference;\r\n    if (isEardrumSupportedObject(additionalRefProps)) {\r\n        refToStore = { ...additionalRefProps, ...refToStore };\r\n    }\r\n    this.refs.push(refToStore);\r\n  } else {\r\n    // Determine which listeners to remove\r\n    var toRemove = this.refs.filter((ref: EventHandlerReference, index: number, array: EventHandlerReference[]) => {\r\n      var shouldBeRemoved;\r\n      if (typeof listenerRemovalCondition !== 'function') {\r\n        shouldBeRemoved = true;\r\n      } else {\r\n        shouldBeRemoved = listenerRemovalCondition(ref, index, array);\r\n      }\r\n\r\n      if (shouldBeRemoved) {\r\n          // Delete refs of removed event listeners\r\n          this.refs.splice(index, 1);\r\n      }\r\n      return shouldBeRemoved;\r\n    });\r\n\r\n    // Remove listeners\r\n    toRemove.forEach((ref: EventHandlerReference) => {\r\n      eventTarget[detachMethodName](eventType, ref.handler, ref.options);\r\n    });\r\n  }\r\n}\r\n  \r\n/**\r\n * Add or remove an unhandledRejection event listener from axios instance\r\n * Calls listenWithCleanup with appropriate parameters\r\n *\r\n * @param {boolean} attach Whether the listener needs to be added (true) or removed (false)\r\n * @param {object} eardrumConfigureArgs Parameters of the configure method\r\n */\r\nfunction toggleListener(\r\n  this: Eardrum,\r\n  attach: boolean,\r\n  eardrumConfigureArgs: EardrumConfigureArgs\r\n): void|never {\r\n  // Typescript narrowing\r\n  const { object, handler, listener, additionalRefProps } = eardrumConfigureArgs;\r\n  const narrowedAdditionalRefProps = additionalRefProps as { [index: PropertyKey]: any };\r\n  const narrowedListener = listener as {\r\n    type?: string;\r\n    target?: EardrumTarget; // defaults to global object\r\n    options?: EventListenerOptions;\r\n  }\r\n  let { type, target } = narrowedListener;\r\n  var narrowedHandler = handler as Function;\r\n  var narrowedTarget = target as EardrumTarget;\r\n  var handlerWrapper: Function;\r\n\r\n  var attachMethodName: string;\r\n  var detachMethodName: string;\r\n\r\n  if (isNodeEnv()) {\r\n    // For node attach listener on process by default\r\n    if (!isEventTargetOrEmitter(narrowedTarget)) {\r\n      narrowedTarget = process;\r\n    }\r\n    attachMethodName = 'addListener';\r\n    detachMethodName = 'removeListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumConfigureArgs);\r\n    };\r\n  } else if (typeof window !== 'undefined') {\r\n    // For browsers attach listener on window by default\r\n    if (!isEventTargetOrEmitter(narrowedTarget)) {\r\n      narrowedTarget = window;\r\n    }\r\n    attachMethodName = 'addEventListener';\r\n    detachMethodName = 'removeEventListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumConfigureArgs);\r\n    };\r\n  } else {\r\n    throw new Error('This environment does not support eardrum.js');\r\n  }\r\n\r\n  (listenWithCleanup.bind(this, {\r\n    ...eardrumConfigureArgs,\r\n    handler: handlerWrapper,\r\n    listener: {\r\n      ...narrowedListener,\r\n      target: narrowedTarget,\r\n      type: type || ''\r\n    },\r\n    additionalRefProps: narrowedAdditionalRefProps,\r\n    attachMethodName,\r\n    detachMethodName,\r\n    attach\r\n  }))();\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = true\r\n * @param {object} eardrumConfigureArgs Parameters of the eardrum configure method\r\n */\r\nexport function installListener(this: Eardrum, eardrumConfigureArgs: EardrumConfigureArgs) {\r\n  (toggleListener.bind(this, true, eardrumConfigureArgs))();\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = false\r\n * @param {object} eardrumConfigureArgs Parameters of the eardrum configure method\r\n */\r\nexport function ejectListener(this: Eardrum, eardrumConfigureArgs: EardrumConfigureArgs) {\r\n  (toggleListener.bind(this, false, eardrumConfigureArgs))();\r\n}","import { isEardrumSupportedObject, throwIfPropIsNotConfigurable, isFunction } from \"../utils\";\r\n\r\nexport default function (eardrumConfigureArgs: EardrumConfigureArgs): EardrumConfigureArgs|never {\r\n    let {\r\n        object,\r\n        property,\r\n        handler,\r\n        additionalRefProps = {},\r\n        listener = {\r\n            type: '',\r\n            target: undefined,\r\n            options: undefined\r\n        }\r\n    } = eardrumConfigureArgs;\r\n    // Validate object\r\n    if (!isEardrumSupportedObject(object)) throw new Error('Eardrum does not support this object');\r\n\r\n    // Validate property\r\n    /*const descriptor = */throwIfPropIsNotConfigurable(\r\n        { object, key: property },\r\n        `Eardrum cannot configure property ${property.toString()} of provided object because it is not configurable`\r\n    );\r\n\r\n    // Validate event handler\r\n    if (typeof handler === 'undefined') {\r\n        // Handler argument is missing\r\n        // => should default to provided property value (if is function)\r\n        if (isFunction(object[property])) {\r\n            handler = object[property];\r\n            eardrumConfigureArgs.handler = handler;\r\n        }\r\n    } \r\n\r\n    return {\r\n        ...eardrumConfigureArgs,\r\n        object,\r\n        property,\r\n        handler,\r\n        additionalRefProps,\r\n        listener\r\n    };\r\n};\r\n","import Eardrum from '../Eardrum';\r\nimport { isNodeEnv, emptyArray } from '../utils';\r\n\r\nexport function resetStoredValues (this: Eardrum): boolean {\r\n\ttry {\r\n\t\temptyArray(this.refs);\r\n\t\tthis.lastConfiguredObject.current = null;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\treturn false;\r\n\t}\r\n};\r\n\r\n/* Remove all listeners and reset stored values */\r\nexport default function reset (this: Eardrum): boolean {\r\n\ttry {\r\n\t\t// Remove all listeners\r\n\t\tconst detachMethod = isNodeEnv() ? 'removeListener' : 'removeEventListener';\r\n\t\tthis.refs.forEach((ref: EventHandlerReference) => {\r\n\t\t\tconst narrowedTarget = ref.target as any;\r\n\t\t\tnarrowedTarget[detachMethod](ref.eventType, ref.handler, ref.options);\r\n\t\t});\r\n\r\n\t\t// Reset stored values\r\n\t\t(() => resetStoredValues.bind(this))();\r\n\t\t\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\treturn false;\r\n\t}\r\n};","/**\r\n * Create private property identifier from public property\r\n * @param {string|symbol} publicPropName The public property identifier from which to derive private prop name\r\n * @returns {string|symbol}\r\n */\r\nexport const createPrivatePropName = <T extends EardrumSupportedPropertyKey>(publicPropName: T): T|never => {\r\n    if (typeof publicPropName === 'symbol') {\r\n        // Return new symbol\r\n        return Symbol() as any;\r\n    }\r\n    if (typeof publicPropName === 'string') {\r\n        return `_${publicPropName}` as any;\r\n    }\r\n    throw new Error('Eardrum does not support property keys of type ' + typeof publicPropName);\r\n};\r\n\r\n/**\r\n * Returns true if the environment is node, false otherwise\r\n * @returns {Boolean} boolean\r\n */\r\nexport const isNodeEnv = (): boolean => {\r\n    return typeof window === 'undefined';\r\n};\r\n\r\n/**\r\n * Determine if a value is a Function\r\n * @param {Object} val The value to test\r\n * @returns {boolean}\r\n */\r\nexport const isFunction = (val: unknown): boolean => toString.call(val) === '[object Function]';\r\n\r\n/**\r\n * Determine if a value is an Object configurable by Eardrum\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEardrumSupportedObject = (val: unknown): boolean => {\r\n    if (toString.call(val) !== '[object Object]') {\r\n      return false;\r\n    } \r\n    return true;\r\n};\r\n\r\n/**\r\n * Determine if a value is an object is an EventTarget (for DOM) | EventEmitter (for Node)\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEventTargetOrEmitter = (val?: { [index: PropertyKey]: any }): boolean => {\r\n    if (!val) return false;\r\n    \r\n    if (\r\n        (\r\n            typeof val['addEventListener'] === 'function' &&\r\n            typeof val['removeEventListener'] === 'function'\r\n        ) ||\r\n        (\r\n            typeof val['addListener'] === 'function' &&\r\n            typeof val['removeListener'] === 'function'\r\n        )\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Removes all indexes from an array\r\n *\r\n * @param {Array} val The other to empty\r\n */\r\nexport const emptyArray = (val: Array<unknown>): void => {\r\n    if (\r\n        typeof val.length !== 'number' ||\r\n        typeof val.pop !== 'function' ||\r\n        !Array.isArray(val)\r\n    ) {\r\n        throw new Error('Invalid argument passed to emptyArray: argument should be an array');\r\n    }\r\n    while(val.length > 0) {\r\n        val.pop();\r\n    } \r\n};\r\n\r\n/**\r\n * Throw error if object property is not configurable\r\n * @param {Object} object The object to inspect\r\n * @param {string|symbol} property The object property to check on\r\n * @param {string?} msg Message of thrown error if property is not configurable\r\n */\r\nexport const throwIfPropIsNotConfigurable = (\r\n    { object, key }: { object: Object, key: EardrumSupportedPropertyKey },\r\n    msg?: string\r\n): never|undefined|PropertyDescriptor => {\r\n    // Default error msg\r\n    if (typeof msg !== 'string') msg = `Error: property '${key.toString()}' is not configurable`;\r\n\r\n    // Get property descriptor\r\n    const descriptor = Object.getOwnPropertyDescriptor(object, key);\r\n    if (typeof descriptor !== 'undefined') {\r\n        // Throw if not configurable\r\n        if (!descriptor.configurable) {\r\n            throw new Error(msg);\r\n        } \r\n    }\r\n\r\n    // Otherwise return property descriptor\r\n    return descriptor;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Eardrum from './core/Eardrum';\r\nexport default new Eardrum();\r\n"],"names":["root","factory","exports","module","define","amd","this","Eardrum","refs","lastConfiguredObject","current","configure","bind","reset","eardrumConfigureArgs","eardrumConfigureArgsValidated","object","property","value","handler","install","installListener","eject","ejectListener","_property","createPrivatePropName","isFunction","Object","defineProperties","writable","configurable","enumerable","get","set","newValue","listenWithCleanup","attach","attachMethodName","detachMethodName","listener","listenerRemovalCondition","additionalRefProps","target","options","eventTarget","eventType","type","Error","refToStore","isEardrumSupportedObject","push","filter","ref","index","array","shouldBeRemoved","splice","forEach","toggleListener","handlerWrapper","narrowedAdditionalRefProps","narrowedListener","narrowedHandler","narrowedTarget","isNodeEnv","isEventTargetOrEmitter","process","e","window","undefined","throwIfPropIsNotConfigurable","key","toString","resetStoredValues","emptyArray","error","publicPropName","Symbol","val","call","length","pop","Array","isArray","msg","descriptor","getOwnPropertyDescriptor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}