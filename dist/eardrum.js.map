{"version":3,"file":"eardrum.js","mappings":"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","sources":["webpack://eardrum/webpack/universalModuleDefinition","webpack://eardrum/./src/core/Eardrum.ts","webpack://eardrum/./src/core/Ref.ts","webpack://eardrum/./src/core/reset/index.ts","webpack://eardrum/./src/core/utils.ts","webpack://eardrum/./src/core/watch/index.ts","webpack://eardrum/./src/core/watch/listen.ts","webpack://eardrum/./src/core/watch/validateEardrumWatchArgs.ts","webpack://eardrum/webpack/bootstrap","webpack://eardrum/./src/eardrum.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"eardrum\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"eardrum\"] = factory();\n\telse\n\t\troot[\"eardrum\"] = factory();\n})(this, function() {\nreturn ","import watch from './watch';\r\nimport reset from './reset';\r\nimport EardrumRef from './Ref';\r\n\r\nexport default class Eardrum {\r\n\tconstructor () {\r\n\t\tthis.watch = watch.bind(this);\r\n\t\tthis.reset = reset.bind(this);\r\n\t}\r\n\r\n\tpublic readonly watch: (args: EardrumWatchArgs) => void;\r\n\tpublic readonly reset: () => void;\r\n\r\n\tpublic readonly Eardrum = Eardrum;\r\n\tpublic readonly EardrumRef = EardrumRef;\r\n\r\n\t// Stored values\r\n\tpublic readonly refs: EardrumRef[] = [];\r\n\tpublic readonly lastWatched: {\r\n\t\tcurrent: EardrumSupportedObject|null\r\n\t} = { current: null };\r\n};","import { isNodeEnv } from \"./utils\";\r\n\r\nexport default class EardrumRef implements EventHandlerReference {\r\n    constructor ({\r\n        handler,\r\n        eventType,\r\n        options,\r\n        object,\r\n        property,\r\n        target,\r\n        eardrumInstanceRefs\r\n    }: EventHandlerReference) {\r\n        this.handler = handler;\r\n        this.eventType = eventType;\r\n        this.options = options;\r\n        this.object = object;\r\n        this.property = property;\r\n        this.target = target;\r\n        this.eardrumInstanceRefs = eardrumInstanceRefs;\r\n    }\r\n\r\n    public readonly handler;\r\n    public readonly eventType;\r\n    public readonly options;\r\n    public readonly object;\r\n    public readonly property;\r\n    public readonly target;\r\n    private readonly eardrumInstanceRefs: EardrumRef[];\r\n\r\n    /**\r\n     * Remove listener and eject reffalse if failed\r\n     * \r\n     * @returns {boolean} True if successful, \r\n     */\r\n    public readonly eject = (): boolean => {\r\n        const detachMethodName = isNodeEnv() ? 'removeListener' : 'removeEventListener';\r\n        // Remove listener\r\n        const eventTarget = this.target as any; // allow indexation by string\r\n        eventTarget[detachMethodName](this.eventType, this.handler, this.options);\r\n\r\n        // Eject ref\r\n        for (let i = 0; i < this.eardrumInstanceRefs.length; i++) {\r\n            const ref = this.eardrumInstanceRefs[i];\r\n            if (ref === this) {\r\n                this.eardrumInstanceRefs.splice(i, 1);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","import Eardrum from '../Eardrum';\r\nimport EardrumRef from '../Ref';\r\nimport { isNodeEnv, emptyArray } from '../utils';\r\n\r\n/* Remove all listeners and reset stored values */\r\nexport default function reset (this: Eardrum): boolean {\r\n\ttry {\r\n\t\t// Remove all listeners\r\n\t\tconst detachMethod = isNodeEnv() ? 'removeListener' : 'removeEventListener';\r\n\t\tthis.refs.forEach((ref: EardrumRef) => {\r\n\t\t\tconst narrowedTarget = ref.target as any;\r\n\t\t\tnarrowedTarget[detachMethod](ref.eventType, ref.handler, ref.options);\r\n\t\t});\r\n\r\n\t\t// Reset stored values\r\n\t\ttry {\r\n\t\t\temptyArray(this.refs);\r\n\t\t\tthis.lastWatched.current = null;\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\treturn false;\r\n\t}\r\n};","/**\r\n * Create private property identifier from public property\r\n * @param {string|symbol} publicPropName The public property identifier from which to derive private prop name\r\n * @returns {string|symbol}\r\n */\r\nexport const createPrivatePropName = <T extends EardrumSupportedPropertyKey>(publicPropName: T): T|never => {\r\n    if (typeof publicPropName === 'symbol') {\r\n        // Return new symbol\r\n        return Symbol() as any;\r\n    }\r\n    if (typeof publicPropName === 'string') {\r\n        return `_${publicPropName}` as any;\r\n    }\r\n    throw new Error('Eardrum does not support property keys of type ' + typeof publicPropName);\r\n};\r\n\r\n/**\r\n * Returns true if the environment is node, false otherwise\r\n * @returns {Boolean} boolean\r\n */\r\nexport const isNodeEnv = (): boolean => {\r\n    return typeof window === 'undefined';\r\n};\r\n\r\n/**\r\n * Determine if a value is a Function\r\n * @param {Object} val The value to test\r\n * @returns {boolean}\r\n */\r\nexport const isFunction = (val: unknown): boolean => toString.call(val) === '[object Function]';\r\n\r\n/**\r\n * Determine if a value is an Object configurable by Eardrum\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEardrumSupportedObject = (val: unknown): boolean => {\r\n    if (toString.call(val) !== '[object Object]') {\r\n      return false;\r\n    } \r\n    return true;\r\n};\r\n\r\n/**\r\n * Determine if a value is an object is an EventTarget (for DOM) | EventEmitter (for Node)\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEventTargetOrEmitter = (val?: { [index: PropertyKey]: any }): boolean => {\r\n    if (!val) return false;\r\n    \r\n    if (\r\n        (\r\n            typeof val['addEventListener'] === 'function' &&\r\n            typeof val['removeEventListener'] === 'function'\r\n        ) ||\r\n        (\r\n            typeof val['addListener'] === 'function' &&\r\n            typeof val['removeListener'] === 'function'\r\n        )\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Removes all indexes from an array\r\n *\r\n * @param {Array} val The other to empty\r\n */\r\nexport const emptyArray = (val: Array<unknown>): void => {\r\n    if (\r\n        typeof val.length !== 'number' ||\r\n        typeof val.pop !== 'function' ||\r\n        !Array.isArray(val)\r\n    ) {\r\n        throw new Error('Invalid argument passed to emptyArray: argument should be an array');\r\n    }\r\n    while(val.length > 0) {\r\n        val.pop();\r\n    } \r\n};\r\n\r\n/**\r\n * Throw error if object property is not configurable\r\n * @param {Object} object The object to inspect\r\n * @param {string|symbol} property The object property to check on\r\n * @param {string?} msg Message of thrown error if property is not configurable\r\n */\r\nexport const throwIfPropIsNotConfigurable = (\r\n    { object, key }: { object: Object, key: EardrumSupportedPropertyKey },\r\n    msg?: string\r\n): never|undefined|PropertyDescriptor => {\r\n    // Default error msg\r\n    if (typeof msg !== 'string') msg = `Error: property '${key.toString()}' is not configurable`;\r\n\r\n    // Get property descriptor\r\n    const descriptor = Object.getOwnPropertyDescriptor(object, key);\r\n    if (typeof descriptor !== 'undefined') {\r\n        // Throw if not configurable\r\n        if (!descriptor.configurable) {\r\n            throw new Error(msg);\r\n        } \r\n    }\r\n\r\n    // Otherwise return property descriptor\r\n    return descriptor;\r\n}","import Eardrum from '../Eardrum';\r\nimport validateEardrumWatchArgs from './validateEardrumWatchArgs';\r\nimport { installListener, ejectListener } from './listen';\r\nimport { isFunction, createPrivatePropName } from '../utils';\r\n\r\n/**\r\n * Configure object property to automatically manage event listeners in setter function\r\n *\r\n * @param {object} eardrumWatchArgs Options object\r\n */\r\nexport default function watch (this: Eardrum, eardrumWatchArgs: EardrumWatchArgs): void {\r\n  // Validation\r\n  const eardrumWatchArgsValidated = validateEardrumWatchArgs(eardrumWatchArgs);\r\n  const {\r\n    object,\r\n    property,\r\n    value,\r\n    handler\r\n  } = eardrumWatchArgsValidated;\r\n\r\n  // Bind context\r\n  const install = installListener.bind(this, eardrumWatchArgsValidated);\r\n  const eject = ejectListener.bind(this, eardrumWatchArgsValidated);\r\n  /*\r\n  const ejectLast = ejectListener.bind(this, {\r\n    ...eardrumWatchArgsValidated,\r\n    object: lastWatched.current\r\n  });\r\n  */\r\n\r\n  // Create private property\r\n  const _property = createPrivatePropName(property);\r\n\r\n  // Clear previous event listener\r\n  /*if (this.lastWatched.current /* && this.lastWatched.current === object *//*) {\r\n    ejectLast();\r\n  }*/\r\n  this.lastWatched.current = object;\r\n\r\n  // Attach initial event listener\r\n  if (isFunction(handler)) {\r\n  \tinstall();\r\n  }\r\n\r\n  // Define setter/getter for defaultReject\r\n  Object.defineProperties(object, {\r\n  \t[_property]: {\r\n  \t\tvalue: typeof value === 'undefined' ? object[property] : value,\r\n  \t\twritable: true,\r\n      configurable: true,\r\n      enumerable: false\r\n  \t},\r\n  \t[property]: {\r\n\t  \tget: function (this: EardrumSupportedObject): unknown {\r\n\t  \t\treturn this[_property];\r\n\t  \t},\r\n\t    set: function (this: EardrumSupportedObject, newValue: unknown): void {\r\n\t\t    // Clear previous event listener\r\n\t\t    eject();\r\n\r\n\t\t    // Replace defaultReject\r\n\t\t    this[_property] = newValue;\r\n\r\n\t\t    // Attach new listener\r\n\t\t    if (isFunction(newValue)) {\r\n\t        install();\r\n\t\t    }\r\n\t    },\r\n      configurable: true,\r\n      enumerable: true\r\n\t  }\r\n  });\r\n};","import Eardrum from '../Eardrum';\r\nimport EardrumRef from '../Ref';\r\nimport { isEardrumSupportedObject, isEventTargetOrEmitter, isNodeEnv } from '../utils';\r\n\r\ninterface ListenWithCleanupOptions extends EardrumWatchArgs {\r\n  attachMethodName: string;\r\n  detachMethodName: string;\r\n  attach: boolean;\r\n  listener: {\r\n    type: string;\r\n    target: EardrumTarget; // defaults to global object\r\n    options?: EventListenerOptions;\r\n  };\r\n  additionalRefProps: { [index: PropertyKey]: any }\r\n}\r\n/**\r\n * Store references of added handlers in an Array and remove from that\r\n *\r\n * @param {object} options EardrumWatchArgs with additional parameters\r\n */\r\nfunction listenWithCleanup(this: Eardrum, {\r\n  attach,\r\n  attachMethodName, detachMethodName,\r\n  object,\r\n  property,\r\n  listener,\r\n  handler,\r\n  listenerRemovalCondition,\r\n  additionalRefProps\r\n}: ListenWithCleanupOptions): void {\r\n  var { target, options } = listener;\r\n  var eventTarget = target as any; // allow indexation by string\r\n  var eventType =  listener.type;\r\n\r\n  if (!eventTarget[attachMethodName] || !eventTarget[detachMethodName]) {\r\n    throw new Error('Event target is invalid');\r\n  }\r\n\r\n  if (attach) {\r\n    // Add listener\r\n    eventTarget[attachMethodName](eventType, handler, options);\r\n\r\n    // Store reference to handler\r\n    let refParams: EventHandlerReference = {\r\n      handler,\r\n      eventType,\r\n      options,\r\n      object,\r\n      property,\r\n      target: eventTarget,\r\n      eardrumInstanceRefs: this.refs\r\n    };\r\n    if (isEardrumSupportedObject(additionalRefProps)) {\r\n        refParams = { ...additionalRefProps, ...refParams };\r\n    }\r\n    const refToStore = new EardrumRef(refParams);\r\n    this.refs.push(refToStore);\r\n  } else {\r\n    // Determine which listeners to remove\r\n    var toRemove = this.refs.filter((ref: EardrumRef, index: number, array: Array<EardrumRef>) => {\r\n      var shouldBeRemoved;\r\n      if (typeof listenerRemovalCondition !== 'function') {\r\n        shouldBeRemoved = true;\r\n      } else {\r\n        shouldBeRemoved = listenerRemovalCondition(ref, index, array);\r\n      }\r\n\r\n      if (shouldBeRemoved) {\r\n          // Delete refs of removed event listeners\r\n          this.refs.splice(index, 1);\r\n      }\r\n      return shouldBeRemoved;\r\n    });\r\n\r\n    // Remove listeners\r\n    toRemove.forEach((ref: EardrumRef) => {\r\n      eventTarget[detachMethodName](eventType, ref.handler, ref.options);\r\n    });\r\n  }\r\n}\r\n  \r\n/**\r\n * Add or remove an unhandledRejection event listener from axios instance\r\n * Calls listenWithCleanup with appropriate parameters\r\n *\r\n * @param {boolean} attach Whether the listener needs to be added (true) or removed (false)\r\n * @param {object} eardrumWatchArgs Parameters of the watch method\r\n */\r\nfunction toggleListener(\r\n  this: Eardrum,\r\n  attach: boolean,\r\n  eardrumWatchArgs: EardrumWatchArgs\r\n): void|never {\r\n  // Typescript narrowing\r\n  const { handler, listener, additionalRefProps } = eardrumWatchArgs;\r\n  const narrowedAdditionalRefProps = additionalRefProps as { [index: PropertyKey]: any };\r\n  const narrowedListener = listener as {\r\n    type?: string;\r\n    target?: EardrumTarget; // defaults to global object\r\n    options?: EventListenerOptions;\r\n  }\r\n  let { type, target } = narrowedListener;\r\n  var narrowedHandler = handler as Function;\r\n  var narrowedTarget = target as EardrumTarget;\r\n  var handlerWrapper: Function;\r\n\r\n  var attachMethodName: string;\r\n  var detachMethodName: string;\r\n\r\n  if (isNodeEnv()) {\r\n    // For node attach listener on process by default\r\n    if (!isEventTargetOrEmitter(narrowedTarget)) {\r\n      narrowedTarget = process;\r\n    }\r\n    attachMethodName = 'addListener';\r\n    detachMethodName = 'removeListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumWatchArgs);\r\n    };\r\n  } else if (typeof window !== 'undefined') {\r\n    // For browsers attach listener on window by default\r\n    if (!isEventTargetOrEmitter(narrowedTarget)) {\r\n      narrowedTarget = window;\r\n    }\r\n    attachMethodName = 'addEventListener';\r\n    detachMethodName = 'removeEventListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumWatchArgs);\r\n    };\r\n  } else {\r\n    throw new Error('This environment does not support eardrum.js');\r\n  }\r\n\r\n  (listenWithCleanup.bind(this, {\r\n    ...eardrumWatchArgs,\r\n    handler: handlerWrapper,\r\n    listener: {\r\n      ...narrowedListener,\r\n      target: narrowedTarget,\r\n      type: type || ''\r\n    },\r\n    additionalRefProps: narrowedAdditionalRefProps,\r\n    attachMethodName,\r\n    detachMethodName,\r\n    attach\r\n  }))();\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = true\r\n * @param {object} eardrumWatchArgs Parameters of the eardrum watch method\r\n */\r\nexport function installListener(this: Eardrum, eardrumWatchArgs: EardrumWatchArgs) {\r\n  (toggleListener.bind(this, true, eardrumWatchArgs))();\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = false\r\n * @param {object} eardrumWatchArgs Parameters of the eardrum watch method\r\n */\r\nexport function ejectListener(this: Eardrum, eardrumWatchArgs: EardrumWatchArgs) {\r\n  (toggleListener.bind(this, false, eardrumWatchArgs))();\r\n}","import { isEardrumSupportedObject, throwIfPropIsNotConfigurable, isFunction } from \"../utils\";\r\n\r\nexport default function (eardrumWatchArgs: EardrumWatchArgs): EardrumWatchArgs|never {\r\n    let {\r\n        object,\r\n        property,\r\n        handler,\r\n        additionalRefProps = {},\r\n        listener = {\r\n            type: '',\r\n            target: undefined,\r\n            options: undefined\r\n        }\r\n    } = eardrumWatchArgs;\r\n    // Validate object\r\n    if (!isEardrumSupportedObject(object)) throw new Error('Eardrum does not support this object');\r\n\r\n    // Validate property\r\n    /*const descriptor = */throwIfPropIsNotConfigurable(\r\n        { object, key: property },\r\n        `Eardrum cannot watch property ${property.toString()} of provided object because it is not configurable`\r\n    );\r\n\r\n    // Validate event handler\r\n    if (typeof handler === 'undefined') {\r\n        // Handler argument is missing\r\n        // => should default to provided property value (if is function)\r\n        if (isFunction(object[property])) {\r\n            handler = object[property];\r\n            eardrumWatchArgs.handler = handler;\r\n        }\r\n    } \r\n\r\n    return {\r\n        ...eardrumWatchArgs,\r\n        object,\r\n        property,\r\n        handler,\r\n        additionalRefProps,\r\n        listener\r\n    };\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import Eardrum from './core/Eardrum';\r\nexport default new Eardrum();\r\n"],"names":["root","factory","exports","module","define","amd","this","Eardrum","EardrumRef","refs","lastWatched","current","watch","bind","reset","handler","eventType","options","object","property","target","eardrumInstanceRefs","eject","detachMethodName","isNodeEnv","i","length","splice","forEach","ref","emptyArray","err","error","createPrivatePropName","publicPropName","Symbol","Error","window","isFunction","val","toString","call","isEardrumSupportedObject","isEventTargetOrEmitter","pop","Array","isArray","throwIfPropIsNotConfigurable","msg","key","descriptor","Object","getOwnPropertyDescriptor","configurable","eardrumWatchArgs","eardrumWatchArgsValidated","value","install","installListener","ejectListener","_property","defineProperties","writable","enumerable","get","set","newValue","listenWithCleanup","attach","attachMethodName","listener","listenerRemovalCondition","additionalRefProps","eventTarget","type","refParams","refToStore","push","filter","index","array","shouldBeRemoved","toggleListener","handlerWrapper","narrowedAdditionalRefProps","narrowedListener","narrowedHandler","narrowedTarget","process","e","undefined","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}