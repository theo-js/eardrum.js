{"version":3,"file":"eardrum.js","mappings":"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","sources":["webpack://eardrum/webpack/universalModuleDefinition","webpack://eardrum/./src/core/configure/index.ts","webpack://eardrum/./src/core/configure/listen.ts","webpack://eardrum/./src/core/configure/validateEardrumConfigureArgs.ts","webpack://eardrum/./src/core/storedValues/index.ts","webpack://eardrum/./src/core/utils.ts","webpack://eardrum/webpack/bootstrap","webpack://eardrum/./src/eardrum.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"eardrum\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"eardrum\"] = factory();\n\telse\n\t\troot[\"eardrum\"] = factory();\n})(this, function() {\nreturn ","import { lastConfiguredObject } from '../storedValues';\r\nimport validateEardrumConfigureArgs from './validateEardrumConfigureArgs';\r\nimport { installListener, ejectListener } from './listen';\r\nimport { isFunction, createPrivatePropName } from '../utils';\r\n\r\n/**\r\n * Configure object property to automatically manage event listeners \r\n *\r\n * @param {object} eardrumConfigureArgs Options object\r\n */\r\nexport default function configure (eardrumConfigureArgs: EardrumConfigureArgs): void {\r\n  // Validation\r\n  let {\r\n    object,\r\n    property,\r\n    handler\r\n  } = validateEardrumConfigureArgs(eardrumConfigureArgs);\r\n\r\n  // Create private property\r\n  const _property = createPrivatePropName(property);\r\n\r\n  // Clear previous event listener\r\n  /*if (lastConfiguredObject.current /* && lastConfiguredObject.current === object *//*) {\r\n    ejectListener(lastConfiguredObject.current);\r\n  }*/\r\n  lastConfiguredObject.current = object;\r\n\r\n  // Attach initial event listener\r\n  if (isFunction(handler)) {\r\n  \tinstallListener(object);\r\n  }\r\n\r\n  // Define setter/getter for defaultReject\r\n  Object.defineProperties(object, {\r\n  \t[_property]: {\r\n  \t\tvalue: object[property],\r\n  \t\twritable: true, configurable: true\r\n  \t},\r\n  \t[property]: {\r\n\t  \tget: function (this: EardrumSupportedObject): unknown {\r\n\t  \t\treturn this[_property];\r\n\t  \t},\r\n\t    set: function (this: EardrumSupportedObject, newValue: unknown): void {\r\n\t\t    // Clear previous event listener\r\n\t\t    ejectListener(object);\r\n\r\n\t\t    // Replace defaultReject\r\n\t\t    this[_property] = newValue;\r\n\r\n\t\t    // Attach new listener\r\n\t\t    if (isFunction(newValue)) {\r\n\t          installListener(object);\r\n\t\t    }\r\n\t    }\r\n\t  }\r\n  });\r\n};","import { handlerReferences } from '../storedValues';\r\nimport { isEardrumSupportedObject, isNodeEnv } from '../utils';\r\n\r\n/**\r\n * Store references of added handlers in an Array and remove from that\r\n *\r\n * @param {boolean} attach Whether the listener needs to be added (true) or removed (false)\r\n * @param {Function} handler The handler which will be added in case attach is true\r\n * @param {Object} target The object on which listener is attached/removed\r\n * @param {string} eventType The type of the event we want to listen to\r\n * @param {ListenerRemovalConditionCallback} listenerRemovalCondition Callback executed during iteration of handlerReferences.\r\n * - Returns a condition at which a listener should be removed\r\n * - Removes all listeners by default\r\n * @param {Object} [additionalHandlerRefProperties] Object to merge with EventHandlerReference\r\n * @param {string} [attachMethodName=addEventListener] The method of target object used to attach a listener;\r\n * @param {string} [detachMethodName=removeEventListener] The method of target object used to remove a listener;\r\n */\r\n function listenWithCleanup(attach: any, handler: any, target: any, eventType: any, listenerRemovalCondition: any, additionalHandlerRefProperties: any, attachMethodName: any, detachMethodName: any) {\r\n    if (attach) {\r\n        // Add listener\r\n      target[attachMethodName](eventType, handler);\r\n  \r\n      // Register reference to handler\r\n      var refToAdd = { handler: handler, eventType: eventType };\r\n      if (isEardrumSupportedObject(additionalHandlerRefProperties)) {\r\n          refToAdd = { ...refToAdd, ...additionalHandlerRefProperties };\r\n      }\r\n      handlerReferences.push(refToAdd);\r\n    } else {\r\n      // Determine which listeners to remove\r\n      var toRemove = handlerReferences.filter(function filterRefs(ref, index, array) {\r\n        var shouldBeRemoved;\r\n        if (typeof listenerRemovalCondition !== 'function') {\r\n          shouldBeRemoved = true;\r\n        } else {\r\n          shouldBeRemoved = listenerRemovalCondition(ref, index, array);\r\n        }\r\n  \r\n        if (shouldBeRemoved) {\r\n            // Delete refs of removed event listeners\r\n            handlerReferences.splice(index, 1);\r\n        }\r\n        return shouldBeRemoved;\r\n      });\r\n  \r\n      // Remove listeners\r\n      toRemove.forEach((ref: EventHandlerReference) => {\r\n        target[detachMethodName](eventType, ref.handler);\r\n      });\r\n    }\r\n  }\r\n  function useDefaultReject (a: any, b: any, c: any, d: any) {}\r\n  \r\n  /**\r\n   * Add or remove an unhandledRejection event listener from axios instance\r\n   * Calls listenWithCleanup with appropriate parameters\r\n   *\r\n   * @param {boolean} attach Whether the listener needs to be added (true) or removed (false)\r\n   * @param {object} instance The axios instance that owns defaultReject\r\n   */\r\n  function toggleListener(attach: boolean, instance: any) {\r\n    var handler;\r\n    var target;\r\n    var attachMethodName;\r\n    var detachMethodName;\r\n    var eventType = 'unhandledrejection';\r\n  \r\n    // Axios instance can only remove its own listeners\r\n    var additionalHandlerRefProperties = { _instanceId: instance._instanceId };\r\n    var listenerRemovalCondition = function listenerRemovalCondition(ref: any) {\r\n      return ref._instanceId === instance._instanceId;\r\n    };\r\n  \r\n    if (isNodeEnv()) {\r\n      // For node attach listener on process\r\n      target = process;\r\n      attachMethodName = 'addListener';\r\n      detachMethodName = 'removeListener';\r\n      handler = function handleServerSideUnhandledRejection(e: any, promise: any) {\r\n        useDefaultReject(instance, e, e, promise);\r\n      };\r\n    } else if (typeof window !== 'undefined') {\r\n      // For browsers attach listener on window\r\n      target = window;\r\n      attachMethodName = 'addEventListener';\r\n      detachMethodName = 'removeEventListener';\r\n      handler = function handleBrowserSideUnhandledRejection(e: any) {\r\n        useDefaultReject(instance, e.reason, e, e.promise);\r\n      };\r\n    } else { return; }\r\n  \r\n    listenWithCleanup(attach, handler, target, eventType, listenerRemovalCondition, additionalHandlerRefProperties, attachMethodName, detachMethodName);\r\n  }\r\n  \r\n  /**\r\n   * Call toggleListener with attach = true\r\n   * @param {Object} instance The axios instance\r\n   */\r\n  export function installListener(object: EardrumSupportedObject) {\r\n    toggleListener(true, object);\r\n  }\r\n  \r\n  /**\r\n   * Call toggleListener with attach = false\r\n   * @param {Object} instance The axios instance\r\n   */\r\n  export function ejectListener(object: EardrumSupportedObject) {\r\n    toggleListener(false, object);\r\n  }","import { isEardrumSupportedObject, throwIfPropIsNotConfigurable, isFunction } from \"../utils\";\r\n\r\nexport default function (eardrumConfigureArgs: EardrumConfigureArgs): EardrumConfigureArgs|never {\r\n    let {\r\n        object,\r\n        property,\r\n        handler\r\n    } = eardrumConfigureArgs;\r\n    // Validate object\r\n    if (!isEardrumSupportedObject(object)) throw new Error('Eardrum does not support this object');\r\n\r\n    // Validate property\r\n    /*const descriptor = */throwIfPropIsNotConfigurable(\r\n        { object, key: property },\r\n        `Eardrum cannot configure property ${property.toString()} of provided object because it is not configurable`\r\n    );\r\n\r\n    // Validate event handler\r\n    if (typeof handler === 'undefined') {\r\n        // Handler argument is missing\r\n        // => should default to provided property value (if is function)\r\n        if (isFunction(object[property])) {\r\n            handler = object[property];\r\n            eardrumConfigureArgs.handler = handler;\r\n        }\r\n    } \r\n\r\n    return eardrumConfigureArgs;\r\n};\r\n","var handlerReferences: EventHandlerReference[] = [];\r\n\r\nvar lastConfiguredObject: { current: EardrumSupportedObject|null } = { current: null };\r\n\r\nexport {\r\n    handlerReferences,\r\n    lastConfiguredObject\r\n};","/**\r\n * Create private property identifier from public property\r\n * @param {string|symbol} publicPropName The public property identifier from which to derive private prop name\r\n * @returns {string|symbol}\r\n */\r\nexport const createPrivatePropName = <T extends EardrumSupportedPropertyKey>(publicPropName: T): T => {\r\n    if (typeof publicPropName === 'number') throw new Error('Eardrum does not support property keys of type number');\r\n    if (typeof publicPropName === 'symbol') {\r\n        // Return new symbol\r\n        return Symbol() as any;\r\n    }\r\n    return `_${publicPropName}` as any;\r\n};\r\n\r\n/**\r\n * Returns true if the environment is node, false otherwise\r\n * @returns {Boolean} boolean\r\n */\r\nexport const isNodeEnv = (): boolean => {\r\n    return typeof window === 'undefined';\r\n};\r\n\r\n/**\r\n * Determine if a value is a Function\r\n * @param {Object} val The value to test\r\n * @returns {boolean}\r\n */\r\nexport const isFunction = (val: unknown): boolean => toString.call(val) === '[object Function]';\r\n\r\n/**\r\n * Determine if a value is an Object configurable by Eardrum\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEardrumSupportedObject = (val: unknown): boolean => {\r\n    if (toString.call(val) !== '[object Object]') {\r\n      return false;\r\n    } \r\n    return true;\r\n};\r\n\r\n/**\r\n * Throw error if object property is not configurable\r\n * @param {Object} object The object to inspect\r\n * @param {string|symbol} property The object property to check on\r\n * @param {string?} msg Message of thrown error if property is not configurable\r\n */\r\nexport const throwIfPropIsNotConfigurable = (\r\n    { object, key }: { object: Object, key: EardrumSupportedPropertyKey },\r\n    msg?: string\r\n): never|PropertyDescriptor => {\r\n    // Default error msg\r\n    if (typeof msg !== 'string') msg = `Error: property '${key.toString()}' is not configurable`;\r\n\r\n    // Get property descriptor\r\n    const descriptor = Object.getOwnPropertyDescriptor(object, key);\r\n    if (typeof descriptor === 'undefined') throw new Error(`Property ${key.toString()} of ${object} has no descriptor`);\r\n\r\n    // Throw if not configurable\r\n    if (!descriptor.configurable) {\r\n        throw new Error(msg);\r\n    }\r\n\r\n    // Otherwise return property descriptor\r\n    return descriptor;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import configure from './core/configure';\r\n\r\nconst eardrum = {\r\n    configure\r\n};\r\n\r\nexport default eardrum;"],"names":["root","factory","exports","module","define","amd","this","eardrumConfigureArgs","object","property","handler","_property","createPrivatePropName","lastConfiguredObject","current","isFunction","installListener","Object","defineProperties","value","writable","configurable","get","set","newValue","ejectListener","toggleListener","attach","instance","target","attachMethodName","detachMethodName","additionalHandlerRefProperties","_instanceId","isNodeEnv","process","e","promise","window","reason","eventType","listenerRemovalCondition","refToAdd","isEardrumSupportedObject","handlerReferences","push","filter","ref","index","array","shouldBeRemoved","splice","forEach","listenWithCleanup","Error","throwIfPropIsNotConfigurable","key","toString","publicPropName","Symbol","val","call","msg","descriptor","getOwnPropertyDescriptor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","eardrum","configure"],"sourceRoot":""}