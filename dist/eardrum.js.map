{"version":3,"file":"eardrum.js","mappings":"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","sources":["webpack://eardrum/webpack/universalModuleDefinition","webpack://eardrum/./src/core/configure/index.ts","webpack://eardrum/./src/core/configure/listen.ts","webpack://eardrum/./src/core/configure/validateEardrumConfigureArgs.ts","webpack://eardrum/./src/core/storedValues/index.ts","webpack://eardrum/./src/core/utils.ts","webpack://eardrum/webpack/bootstrap","webpack://eardrum/./src/eardrum.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"eardrum\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"eardrum\"] = factory();\n\telse\n\t\troot[\"eardrum\"] = factory();\n})(this, function() {\nreturn ","import { lastConfiguredObject } from '../storedValues';\r\nimport validateEardrumConfigureArgs from './validateEardrumConfigureArgs';\r\nimport { installListener, ejectListener } from './listen';\r\nimport { isFunction, createPrivatePropName } from '../utils';\r\n\r\n/**\r\n * Configure object property to automatically manage event listeners \r\n *\r\n * @param {object} eardrumConfigureArgs Options object\r\n */\r\nexport default function configure (eardrumConfigureArgs: EardrumConfigureArgs): void {\r\n  // Validation\r\n  let {\r\n    object,\r\n    property,\r\n    value,\r\n    handler,\r\n    additionalRefProps = {}\r\n  } = validateEardrumConfigureArgs(eardrumConfigureArgs);\r\n\r\n  // Create private property\r\n  const _property = createPrivatePropName(property);\r\n\r\n  // Clear previous event listener\r\n  /*if (lastConfiguredObject.current /* && lastConfiguredObject.current === object *//*) {\r\n    ejectListener({\r\n      ...eardrumConfigureArgs,\r\n      object: lastConfiguredObject.current\r\n    });\r\n  }*/\r\n  lastConfiguredObject.current = object;\r\n\r\n  // Attach initial event listener\r\n  if (isFunction(handler)) {\r\n  \tinstallListener(eardrumConfigureArgs);\r\n  }\r\n\r\n  // Define setter/getter for defaultReject\r\n  Object.defineProperties(object, {\r\n  \t[_property]: {\r\n  \t\tvalue: typeof value === 'undefined' ? object[property] : value,\r\n  \t\twritable: true,\r\n      configurable: true,\r\n      enumerable: false\r\n  \t},\r\n  \t[property]: {\r\n\t  \tget: function (this: EardrumSupportedObject): unknown {\r\n\t  \t\treturn this[_property];\r\n\t  \t},\r\n\t    set: function (this: EardrumSupportedObject, newValue: unknown): void {\r\n\t\t    // Clear previous event listener\r\n\t\t    ejectListener(eardrumConfigureArgs);\r\n\r\n\t\t    // Replace defaultReject\r\n\t\t    this[_property] = newValue;\r\n\r\n\t\t    // Attach new listener\r\n\t\t    if (isFunction(newValue)) {\r\n\t        installListener(eardrumConfigureArgs);\r\n\t\t    }\r\n\t    },\r\n      configurable: true,\r\n      enumerable: true\r\n\t  }\r\n  });\r\n};","import { handlerReferences } from '../storedValues';\r\nimport { isEardrumSupportedObject, isNodeEnv } from '../utils';\r\n\r\ninterface ListenWithCleanupOptions extends EardrumConfigureArgs {\r\n  attachMethodName: string;\r\n  detachMethodName: string;\r\n  attach: boolean;\r\n}\r\n/**\r\n * Store references of added handlers in an Array and remove from that\r\n *\r\n * @param {object} options EardrumConfigureArgs with additional parameters\r\n */\r\nfunction listenWithCleanup({\r\n  attach,\r\n  attachMethodName, detachMethodName,\r\n  object,\r\n  listener,\r\n  handler,\r\n  listenerRemovalCondition,\r\n  additionalRefProps\r\n}: ListenWithCleanupOptions) {\r\n  var { target, bubble } = listener;\r\n  var eventTarget = target as any; // allow indexation by string\r\n  var eventType =  listener.type;\r\n\r\n  if (!eventTarget[attachMethodName] || !eventTarget[detachMethodName]) {\r\n    throw new Error('EventTarget is invalid');\r\n  }\r\n\r\n  if (attach) {\r\n    // Add listener\r\n    eventTarget[attachMethodName](eventType, handler);\r\n\r\n    // Store reference to handler\r\n    var refToStore = { handler, eventType, object } as EventHandlerReference;\r\n    if (isEardrumSupportedObject(additionalRefProps)) {\r\n        refToStore = { ...additionalRefProps, ...refToStore };\r\n    }\r\n    handlerReferences.push(refToStore);\r\n  } else {\r\n    // Determine which listeners to remove\r\n    var toRemove = handlerReferences.filter(function filterRefs(ref, index, array) {\r\n      var shouldBeRemoved;\r\n      if (typeof listenerRemovalCondition !== 'function') {\r\n        shouldBeRemoved = true;\r\n      } else {\r\n        shouldBeRemoved = listenerRemovalCondition(ref, index, array);\r\n      }\r\n\r\n      if (shouldBeRemoved) {\r\n          // Delete refs of removed event listeners\r\n          handlerReferences.splice(index, 1);\r\n      }\r\n      return shouldBeRemoved;\r\n    });\r\n\r\n    // Remove listeners\r\n    toRemove.forEach((ref: EventHandlerReference) => {\r\n      eventTarget[detachMethodName](eventType, ref.handler);\r\n    });\r\n  }\r\n}\r\n  \r\n/**\r\n * Add or remove an unhandledRejection event listener from axios instance\r\n * Calls listenWithCleanup with appropriate parameters\r\n *\r\n * @param {boolean} attach Whether the listener needs to be added (true) or removed (false)\r\n * @param {object} eardrumConfigureArgs Parameters of the configure method\r\n */\r\nfunction toggleListener(\r\n  attach: boolean,\r\n  eardrumConfigureArgs: EardrumConfigureArgs\r\n) {\r\n  var { object, handler, listener } = eardrumConfigureArgs;\r\n  var { target } = listener;\r\n  var narrowedHandler = handler as Function;\r\n  var handlerWrapper: Function;\r\n  var attachMethodName: string;\r\n  var detachMethodName: string;\r\n\r\n  if (isNodeEnv()) {\r\n    // For node attach listener on process by default\r\n    if (!isEardrumSupportedObject(target)) {\r\n      target = process;\r\n    }\r\n    attachMethodName = 'addListener';\r\n    detachMethodName = 'removeListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumConfigureArgs);\r\n    };\r\n  } else if (typeof window !== 'undefined') {\r\n    // For browsers attach listener on window by default\r\n    target = window;\r\n    attachMethodName = 'addEventListener';\r\n    detachMethodName = 'removeEventListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumConfigureArgs);\r\n    };\r\n  } else {\r\n    throw new Error('This environment does not support eardrum.js');\r\n  }\r\n\r\n  listenWithCleanup({\r\n    ...eardrumConfigureArgs,\r\n    handler: handlerWrapper,\r\n    listener: {\r\n      ...listener,\r\n      target\r\n    },\r\n    attachMethodName,\r\n    detachMethodName,\r\n    attach\r\n  });\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = true\r\n * @param {object} eardrumConfigureArgs Parameters of the eardrum configure method\r\n */\r\nexport function installListener(eardrumConfigureArgs: EardrumConfigureArgs) {\r\n  toggleListener(true, eardrumConfigureArgs);\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = false\r\n * @param {object} eardrumConfigureArgs Parameters of the eardrum configure method\r\n */\r\nexport function ejectListener(eardrumConfigureArgs: EardrumConfigureArgs) {\r\n  toggleListener(false, eardrumConfigureArgs);\r\n}","import { isEardrumSupportedObject, throwIfPropIsNotConfigurable, isFunction } from \"../utils\";\r\n\r\nexport default function (eardrumConfigureArgs: EardrumConfigureArgs): EardrumConfigureArgs|never {\r\n    let {\r\n        object,\r\n        property,\r\n        handler\r\n    } = eardrumConfigureArgs;\r\n    // Validate object\r\n    if (!isEardrumSupportedObject(object)) throw new Error('Eardrum does not support this object');\r\n\r\n    // Validate property\r\n    /*const descriptor = */throwIfPropIsNotConfigurable(\r\n        { object, key: property },\r\n        `Eardrum cannot configure property ${property.toString()} of provided object because it is not configurable`\r\n    );\r\n\r\n    // Validate event handler\r\n    if (typeof handler === 'undefined') {\r\n        // Handler argument is missing\r\n        // => should default to provided property value (if is function)\r\n        if (isFunction(object[property])) {\r\n            handler = object[property];\r\n            eardrumConfigureArgs.handler = handler;\r\n        }\r\n    } \r\n\r\n    return eardrumConfigureArgs;\r\n};\r\n","var handlerReferences: EventHandlerReference[] = [];\r\n\r\nvar lastConfiguredObject: { current: EardrumSupportedObject|null } = { current: null };\r\n\r\nexport {\r\n    handlerReferences,\r\n    lastConfiguredObject\r\n};","/**\r\n * Create private property identifier from public property\r\n * @param {string|symbol} publicPropName The public property identifier from which to derive private prop name\r\n * @returns {string|symbol}\r\n */\r\nexport const createPrivatePropName = <T extends EardrumSupportedPropertyKey>(publicPropName: T): T => {\r\n    if (typeof publicPropName === 'number') throw new Error('Eardrum does not support property keys of type number');\r\n    if (typeof publicPropName === 'symbol') {\r\n        // Return new symbol\r\n        return Symbol() as any;\r\n    }\r\n    return `_${publicPropName}` as any;\r\n};\r\n\r\n/**\r\n * Returns true if the environment is node, false otherwise\r\n * @returns {Boolean} boolean\r\n */\r\nexport const isNodeEnv = (): boolean => {\r\n    return typeof window === 'undefined';\r\n};\r\n\r\n/**\r\n * Determine if a value is a Function\r\n * @param {Object} val The value to test\r\n * @returns {boolean}\r\n */\r\nexport const isFunction = (val: unknown): boolean => toString.call(val) === '[object Function]';\r\n\r\n/**\r\n * Determine if a value is an Object configurable by Eardrum\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEardrumSupportedObject = (val: unknown): boolean => {\r\n    if (toString.call(val) !== '[object Object]') {\r\n      return false;\r\n    } \r\n    return true;\r\n};\r\n\r\n/**\r\n * Throw error if object property is not configurable\r\n * @param {Object} object The object to inspect\r\n * @param {string|symbol} property The object property to check on\r\n * @param {string?} msg Message of thrown error if property is not configurable\r\n */\r\nexport const throwIfPropIsNotConfigurable = (\r\n    { object, key }: { object: Object, key: EardrumSupportedPropertyKey },\r\n    msg?: string\r\n): never|undefined|PropertyDescriptor => {\r\n    // Default error msg\r\n    if (typeof msg !== 'string') msg = `Error: property '${key.toString()}' is not configurable`;\r\n\r\n    // Get property descriptor\r\n    const descriptor = Object.getOwnPropertyDescriptor(object, key);\r\n    if (typeof descriptor !== 'undefined') {\r\n        // Throw if not configurable\r\n        if (!descriptor.configurable) {\r\n            throw new Error(msg);\r\n        } \r\n    }\r\n\r\n    // Otherwise return property descriptor\r\n    return descriptor;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import configure from './core/configure';\r\n\r\nconst eardrum = {\r\n    configure\r\n};\r\n\r\nexport default eardrum;"],"names":["root","factory","exports","module","define","amd","this","eardrumConfigureArgs","object","property","value","handler","_property","additionalRefProps","createPrivatePropName","lastConfiguredObject","current","isFunction","installListener","Object","defineProperties","writable","configurable","enumerable","get","set","newValue","ejectListener","toggleListener","attach","handlerWrapper","attachMethodName","detachMethodName","listener","target","narrowedHandler","isNodeEnv","isEardrumSupportedObject","process","e","window","Error","listenerRemovalCondition","eventTarget","eventType","type","refToStore","handlerReferences","push","filter","ref","index","array","shouldBeRemoved","splice","forEach","listenWithCleanup","throwIfPropIsNotConfigurable","key","toString","publicPropName","Symbol","val","call","msg","descriptor","getOwnPropertyDescriptor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","eardrum","configure"],"sourceRoot":""}