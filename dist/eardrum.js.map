{"version":3,"file":"eardrum.js","mappings":"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","sources":["webpack://eardrum/webpack/universalModuleDefinition","webpack://eardrum/./src/core/configure/index.ts","webpack://eardrum/./src/core/configure/listen.ts","webpack://eardrum/./src/core/configure/validateEardrumConfigureArgs.ts","webpack://eardrum/./src/core/storedValues/index.ts","webpack://eardrum/./src/core/utils.ts","webpack://eardrum/webpack/bootstrap","webpack://eardrum/./src/eardrum.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"eardrum\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"eardrum\"] = factory();\n\telse\n\t\troot[\"eardrum\"] = factory();\n})(this, function() {\nreturn ","import { lastConfiguredObject } from '../storedValues';\r\nimport validateEardrumConfigureArgs from './validateEardrumConfigureArgs';\r\nimport { installListener, ejectListener } from './listen';\r\nimport { isFunction, createPrivatePropName } from '../utils';\r\n\r\n/**\r\n * Configure object property to automatically manage event listeners \r\n *\r\n * @param {object} eardrumConfigureArgs Options object\r\n */\r\nexport default function configure (eardrumConfigureArgs: EardrumConfigureArgs): void {\r\n  // Validation\r\n  const eardrumConfigureArgsValidated = validateEardrumConfigureArgs(eardrumConfigureArgs);\r\n  const {\r\n    object,\r\n    property,\r\n    value,\r\n    handler\r\n  } = eardrumConfigureArgsValidated;\r\n\r\n  // Create private property\r\n  const _property = createPrivatePropName(property);\r\n\r\n  // Clear previous event listener\r\n  /*if (lastConfiguredObject.current /* && lastConfiguredObject.current === object *//*) {\r\n    ejectListener({\r\n      ...eardrumConfigureArgsValidated,\r\n      object: lastConfiguredObject.current\r\n    });\r\n  }*/\r\n  lastConfiguredObject.current = object;\r\n\r\n  // Attach initial event listener\r\n  if (isFunction(handler)) {\r\n  \tinstallListener(eardrumConfigureArgsValidated);\r\n  }\r\n\r\n  // Define setter/getter for defaultReject\r\n  Object.defineProperties(object, {\r\n  \t[_property]: {\r\n  \t\tvalue: typeof value === 'undefined' ? object[property] : value,\r\n  \t\twritable: true,\r\n      configurable: true,\r\n      enumerable: false\r\n  \t},\r\n  \t[property]: {\r\n\t  \tget: function (this: EardrumSupportedObject): unknown {\r\n\t  \t\treturn this[_property];\r\n\t  \t},\r\n\t    set: function (this: EardrumSupportedObject, newValue: unknown): void {\r\n\t\t    // Clear previous event listener\r\n\t\t    ejectListener(eardrumConfigureArgsValidated);\r\n\r\n\t\t    // Replace defaultReject\r\n\t\t    this[_property] = newValue;\r\n\r\n\t\t    // Attach new listener\r\n\t\t    if (isFunction(newValue)) {\r\n\t        installListener(eardrumConfigureArgsValidated);\r\n\t\t    }\r\n\t    },\r\n      configurable: true,\r\n      enumerable: true\r\n\t  }\r\n  });\r\n};","import { handlerReferences } from '../storedValues';\r\nimport { isEardrumSupportedObject, isNodeEnv } from '../utils';\r\n\r\ninterface ListenWithCleanupOptions extends EardrumConfigureArgs {\r\n  attachMethodName: string;\r\n  detachMethodName: string;\r\n  attach: boolean;\r\n  listener: {\r\n    type?: string;\r\n    target?: EventTarget | import('events').EventEmitter; // defaults to global object\r\n    bubble?: boolean;\r\n  };\r\n  additionalRefProps: { [index: PropertyKey]: any }\r\n}\r\n/**\r\n * Store references of added handlers in an Array and remove from that\r\n *\r\n * @param {object} options EardrumConfigureArgs with additional parameters\r\n */\r\nfunction listenWithCleanup({\r\n  attach,\r\n  attachMethodName, detachMethodName,\r\n  object,\r\n  listener,\r\n  handler,\r\n  listenerRemovalCondition,\r\n  additionalRefProps\r\n}: ListenWithCleanupOptions): void {\r\n  var { target, bubble } = listener;\r\n  var eventTarget = target as any; // allow indexation by string\r\n  var eventType =  listener.type;\r\n\r\n  if (!eventTarget[attachMethodName] || !eventTarget[detachMethodName]) {\r\n    throw new Error('EventTarget is invalid');\r\n  }\r\n\r\n  if (attach) {\r\n    // Add listener\r\n    eventTarget[attachMethodName](eventType, handler, bubble === true ? true : false);\r\n\r\n    // Store reference to handler\r\n    var refToStore = { handler, eventType, bubble, object, } as EventHandlerReference;\r\n    if (isEardrumSupportedObject(additionalRefProps)) {\r\n        refToStore = { ...additionalRefProps, ...refToStore };\r\n    }\r\n    handlerReferences.push(refToStore);\r\n  } else {\r\n    // Determine which listeners to remove\r\n    var toRemove = handlerReferences.filter(function filterRefs(ref, index, array) {\r\n      var shouldBeRemoved;\r\n      if (typeof listenerRemovalCondition !== 'function') {\r\n        shouldBeRemoved = true;\r\n      } else {\r\n        shouldBeRemoved = listenerRemovalCondition(ref, index, array);\r\n      }\r\n\r\n      if (shouldBeRemoved) {\r\n          // Delete refs of removed event listeners\r\n          handlerReferences.splice(index, 1);\r\n      }\r\n      return shouldBeRemoved;\r\n    });\r\n\r\n    // Remove listeners\r\n    toRemove.forEach((ref: EventHandlerReference) => {\r\n      eventTarget[detachMethodName](eventType, ref.handler, ref.bubble);\r\n    });\r\n  }\r\n}\r\n  \r\n/**\r\n * Add or remove an unhandledRejection event listener from axios instance\r\n * Calls listenWithCleanup with appropriate parameters\r\n *\r\n * @param {boolean} attach Whether the listener needs to be added (true) or removed (false)\r\n * @param {object} eardrumConfigureArgs Parameters of the configure method\r\n */\r\nfunction toggleListener(\r\n  attach: boolean,\r\n  eardrumConfigureArgs: EardrumConfigureArgs\r\n): void|never {\r\n  // Typescript narrowing\r\n  const { object, handler, listener, additionalRefProps } = eardrumConfigureArgs;\r\n  const narrowedAdditionalRefProps = additionalRefProps as { [index: PropertyKey]: any };\r\n  const narrowedListener = listener as {\r\n    type?: string;\r\n    target?: EventTarget | import('events').EventEmitter; // defaults to global object\r\n    bubble?: boolean;\r\n  }\r\n  let { target, bubble } = narrowedListener;\r\n  const narrowedBubble = bubble === true ? true : false;\r\n  var narrowedHandler = handler as Function;\r\n  var handlerWrapper: Function;\r\n\r\n  var attachMethodName: string;\r\n  var detachMethodName: string;\r\n\r\n  if (isNodeEnv()) {\r\n    // For node attach listener on process by default\r\n    if (!isEardrumSupportedObject(target)) {\r\n      target = process;\r\n    }\r\n    attachMethodName = 'addListener';\r\n    detachMethodName = 'removeListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumConfigureArgs);\r\n    };\r\n  } else if (typeof window !== 'undefined') {\r\n    // For browsers attach listener on window by default\r\n    target = window;\r\n    attachMethodName = 'addEventListener';\r\n    detachMethodName = 'removeEventListener';\r\n    handlerWrapper = function (e: Event) {\r\n      narrowedHandler(e, eardrumConfigureArgs);\r\n    };\r\n  } else {\r\n    throw new Error('This environment does not support eardrum.js');\r\n  }\r\n\r\n  listenWithCleanup({\r\n    ...eardrumConfigureArgs,\r\n    handler: handlerWrapper,\r\n    listener: {\r\n      ...narrowedListener,\r\n      target,\r\n      bubble: narrowedBubble\r\n    },\r\n    additionalRefProps: narrowedAdditionalRefProps,\r\n    attachMethodName,\r\n    detachMethodName,\r\n    attach\r\n  });\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = true\r\n * @param {object} eardrumConfigureArgs Parameters of the eardrum configure method\r\n */\r\nexport function installListener(eardrumConfigureArgs: EardrumConfigureArgs) {\r\n  toggleListener(true, eardrumConfigureArgs);\r\n}\r\n\r\n/**\r\n * Call toggleListener with attach = false\r\n * @param {object} eardrumConfigureArgs Parameters of the eardrum configure method\r\n */\r\nexport function ejectListener(eardrumConfigureArgs: EardrumConfigureArgs) {\r\n  toggleListener(false, eardrumConfigureArgs);\r\n}","import { isEardrumSupportedObject, throwIfPropIsNotConfigurable, isFunction } from \"../utils\";\r\n\r\nexport default function (eardrumConfigureArgs: EardrumConfigureArgs): EardrumConfigureArgs|never {\r\n    let {\r\n        object,\r\n        property,\r\n        handler,\r\n        additionalRefProps = {},\r\n        listener = {\r\n            type: '',\r\n            target: undefined,\r\n            bubble: false\r\n        }\r\n    } = eardrumConfigureArgs;\r\n    // Validate object\r\n    if (!isEardrumSupportedObject(object)) throw new Error('Eardrum does not support this object');\r\n\r\n    // Validate property\r\n    /*const descriptor = */throwIfPropIsNotConfigurable(\r\n        { object, key: property },\r\n        `Eardrum cannot configure property ${property.toString()} of provided object because it is not configurable`\r\n    );\r\n\r\n    // Validate event handler\r\n    if (typeof handler === 'undefined') {\r\n        // Handler argument is missing\r\n        // => should default to provided property value (if is function)\r\n        if (isFunction(object[property])) {\r\n            handler = object[property];\r\n            eardrumConfigureArgs.handler = handler;\r\n        }\r\n    } \r\n\r\n    return {\r\n        ...eardrumConfigureArgs,\r\n        object,\r\n        property,\r\n        handler,\r\n        additionalRefProps,\r\n        listener\r\n    };\r\n};\r\n","var handlerReferences: EventHandlerReference[] = [];\r\n\r\nvar lastConfiguredObject: { current: EardrumSupportedObject|null } = { current: null };\r\n\r\nexport {\r\n    handlerReferences,\r\n    lastConfiguredObject\r\n};","/**\r\n * Create private property identifier from public property\r\n * @param {string|symbol} publicPropName The public property identifier from which to derive private prop name\r\n * @returns {string|symbol}\r\n */\r\nexport const createPrivatePropName = <T extends EardrumSupportedPropertyKey>(publicPropName: T): T => {\r\n    if (typeof publicPropName === 'number') throw new Error('Eardrum does not support property keys of type number');\r\n    if (typeof publicPropName === 'symbol') {\r\n        // Return new symbol\r\n        return Symbol() as any;\r\n    }\r\n    return `_${publicPropName}` as any;\r\n};\r\n\r\n/**\r\n * Returns true if the environment is node, false otherwise\r\n * @returns {Boolean} boolean\r\n */\r\nexport const isNodeEnv = (): boolean => {\r\n    return typeof window === 'undefined';\r\n};\r\n\r\n/**\r\n * Determine if a value is a Function\r\n * @param {Object} val The value to test\r\n * @returns {boolean}\r\n */\r\nexport const isFunction = (val: unknown): boolean => toString.call(val) === '[object Function]';\r\n\r\n/**\r\n * Determine if a value is an Object configurable by Eardrum\r\n *\r\n * @param {Object} val The value to test\r\n * @return {boolean} True if value is a plain Object, otherwise false\r\n */\r\nexport const isEardrumSupportedObject = (val: unknown): boolean => {\r\n    if (toString.call(val) !== '[object Object]') {\r\n      return false;\r\n    } \r\n    return true;\r\n};\r\n\r\n/**\r\n * Throw error if object property is not configurable\r\n * @param {Object} object The object to inspect\r\n * @param {string|symbol} property The object property to check on\r\n * @param {string?} msg Message of thrown error if property is not configurable\r\n */\r\nexport const throwIfPropIsNotConfigurable = (\r\n    { object, key }: { object: Object, key: EardrumSupportedPropertyKey },\r\n    msg?: string\r\n): never|undefined|PropertyDescriptor => {\r\n    // Default error msg\r\n    if (typeof msg !== 'string') msg = `Error: property '${key.toString()}' is not configurable`;\r\n\r\n    // Get property descriptor\r\n    const descriptor = Object.getOwnPropertyDescriptor(object, key);\r\n    if (typeof descriptor !== 'undefined') {\r\n        // Throw if not configurable\r\n        if (!descriptor.configurable) {\r\n            throw new Error(msg);\r\n        } \r\n    }\r\n\r\n    // Otherwise return property descriptor\r\n    return descriptor;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import configure from './core/configure';\r\n\r\nconst eardrum = {\r\n    configure\r\n};\r\n\r\nexport default eardrum;"],"names":["root","factory","exports","module","define","amd","this","eardrumConfigureArgs","eardrumConfigureArgsValidated","object","property","value","handler","_property","createPrivatePropName","lastConfiguredObject","current","isFunction","installListener","Object","defineProperties","writable","configurable","enumerable","get","set","newValue","ejectListener","toggleListener","attach","handlerWrapper","attachMethodName","detachMethodName","listener","narrowedAdditionalRefProps","narrowedListener","target","narrowedBubble","narrowedHandler","isNodeEnv","isEardrumSupportedObject","process","e","window","Error","listenerRemovalCondition","additionalRefProps","bubble","eventTarget","eventType","type","refToStore","handlerReferences","push","filter","ref","index","array","shouldBeRemoved","splice","forEach","listenWithCleanup","undefined","throwIfPropIsNotConfigurable","key","toString","publicPropName","Symbol","val","call","msg","descriptor","getOwnPropertyDescriptor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","eardrum","configure"],"sourceRoot":""}